#!/usr/bin/env bash
set -euo pipefail

# AIS Service Manager - Enhanced for 164-Feature System (v3.1)
# Supports both local and Docker deployment
#
# Usage examples:
#   ./ais start                      # start all services locally
#   ./ais start credit_scoring_service
#   ./ais stop api_gateway
#   ./ais restart credit_scoring_service
#   ./ais status                     # show status for all
#   ./ais logs credit_scoring_service --follow --lines 200
#   ./ais health credit_scoring_service
#   ./ais urls                       # print useful URLs
#   ./ais generate-data              # generate 144-feature training data
#   ./ais train-models               # train ensemble models
#   ./ais validate-system            # validate system components
#   ./ais quick-start                # automated setup
#   CREDIT_PORT=4011 ./ais start credit_scoring_service  # override port

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PIDS_DIR="$ROOT_DIR/.ais/pids"
LOGS_DIR="$ROOT_DIR/.ais/logs"
mkdir -p "$PIDS_DIR" "$LOGS_DIR"

declare -A SERVICE_CMD
declare -A SERVICE_PORT
declare -A SERVICE_HEALTH
declare -A SERVICE_DOCS
declare -A SERVICE_TYPE

SERVICES=(
  credit_scoring_service
  api_gateway
  explainability_service
  default_prediction_service
  streamlit_dashboard
  decision_pro_admin
)

# credit_scoring_service (FastAPI)
SERVICE_PORT[credit_scoring_service]="${CREDIT_PORT:-4001}"
SERVICE_CMD[credit_scoring_service]="uvicorn credit_scoring_service.app.main:app --host 0.0.0.0 --port ${SERVICE_PORT[credit_scoring_service]} --reload"
SERVICE_HEALTH[credit_scoring_service]="http://localhost:${SERVICE_PORT[credit_scoring_service]}/health"
SERVICE_DOCS[credit_scoring_service]="http://localhost:${SERVICE_PORT[credit_scoring_service]}/docs"
SERVICE_TYPE[credit_scoring_service]="uvicorn"

# api_gateway (FastAPI)
SERVICE_PORT[api_gateway]="${API_GATEWAY_PORT:-4000}"
SERVICE_CMD[api_gateway]="uvicorn api_gateway.app.main:app --host 0.0.0.0 --port ${SERVICE_PORT[api_gateway]} --reload"
SERVICE_HEALTH[api_gateway]="http://localhost:${SERVICE_PORT[api_gateway]}/health"
SERVICE_DOCS[api_gateway]="http://localhost:${SERVICE_PORT[api_gateway]}/docs"
SERVICE_TYPE[api_gateway]="uvicorn"

# explainability_service (FastAPI)
SERVICE_PORT[explainability_service]="${EXPLAIN_PORT:-4003}"
SERVICE_CMD[explainability_service]="uvicorn explainability_service.app.main:app --host 0.0.0.0 --port ${SERVICE_PORT[explainability_service]} --reload"
SERVICE_HEALTH[explainability_service]="http://localhost:${SERVICE_PORT[explainability_service]}/health"
SERVICE_DOCS[explainability_service]="http://localhost:${SERVICE_PORT[explainability_service]}/docs"
SERVICE_TYPE[explainability_service]="uvicorn"

# default_prediction_service (FastAPI)
SERVICE_PORT[default_prediction_service]="${DEFAULT_PRED_PORT:-4002}"
SERVICE_CMD[default_prediction_service]="uvicorn default_prediction_service.app.main:app --host 0.0.0.0 --port ${SERVICE_PORT[default_prediction_service]} --reload"
SERVICE_HEALTH[default_prediction_service]="http://localhost:${SERVICE_PORT[default_prediction_service]}/health"
SERVICE_DOCS[default_prediction_service]="http://localhost:${SERVICE_PORT[default_prediction_service]}/docs"
SERVICE_TYPE[default_prediction_service]="uvicorn"

# streamlit dashboard
SERVICE_PORT[streamlit_dashboard]="${STREAMLIT_PORT:-4005}"
SERVICE_CMD[streamlit_dashboard]="streamlit run streamlit_dashboard_v2/Home.py --server.port ${SERVICE_PORT[streamlit_dashboard]} --server.headless true"
SERVICE_HEALTH[streamlit_dashboard]="http://localhost:${SERVICE_PORT[streamlit_dashboard]}/"
SERVICE_DOCS[streamlit_dashboard]=""
SERVICE_TYPE[streamlit_dashboard]="streamlit"

# decision_pro_admin (Next.js)
# Mode detection happens dynamically in start_service to allow runtime changes
SERVICE_PORT[decision_pro_admin]="${DECISION_PRO_PORT:-4009}"
SERVICE_HEALTH[decision_pro_admin]="http://localhost:${SERVICE_PORT[decision_pro_admin]}/"
SERVICE_DOCS[decision_pro_admin]=""
SERVICE_TYPE[decision_pro_admin]="nextjs"
# SERVICE_CMD will be set dynamically based on mode in start_service

# Enhanced Colors and Styles
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
DIM='\033[2m'
UNDERLINE='\033[4m'
NC='\033[0m' # No Color

# Icons/Emojis
ICON_SUCCESS="âœ“"
ICON_ERROR="âœ—"
ICON_WARNING="âš "
ICON_INFO="â„¹"
ICON_RUNNING="â–¶"
ICON_STOPPED="â– "
ICON_DOCKER="ðŸ³"
ICON_SERVICE="ðŸ”§"
ICON_HEALTHY="ðŸ’š"
ICON_UNHEALTHY="ðŸ’›"

# Box drawing characters
BOX_H="â”€"
BOX_V="â”‚"
BOX_TL="â”Œ"
BOX_TR="â”"
BOX_BL="â””"
BOX_BR="â”˜"

# Enhanced logging functions
log_info() {
    echo -e "${GREEN}${ICON_SUCCESS}${NC} ${CYAN}[$(date +'%H:%M:%S')]${NC} ${BOLD}$1${NC}"
}

log_error() {
    echo -e "${RED}${ICON_ERROR}${NC} ${RED}[$(date +'%H:%M:%S')] ERROR:${NC} ${BOLD}$1${NC}"
}

log_warning() {
    echo -e "${YELLOW}${ICON_WARNING}${NC} ${YELLOW}[$(date +'%H:%M:%S')] WARNING:${NC} $1"
}

log_success() {
    echo -e "${GREEN}${ICON_SUCCESS}${NC} ${GREEN}${BOLD}$1${NC}"
}

log_header() {
    echo ""
    echo -e "${BOLD}${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BOLD}${BLUE}  $1${NC}"
    echo -e "${BOLD}${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
}

log_section() {
    echo ""
    echo -e "${CYAN}${BOLD}â–¶${NC} ${BOLD}$1${NC}"
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}

# Print a boxed message
print_box() {
    local msg="$1"
    local color="${2:-${BLUE}}"
    local width=${#msg}
    width=$((width + 4))
    
    echo -e "${color}${BOX_TL}$(printf "%${width}s" | tr ' ' "${BOX_H}")${BOX_TR}${NC}"
    echo -e "${color}${BOX_V}${NC}  ${BOLD}$msg${NC}  ${color}${BOX_V}${NC}"
    echo -e "${color}${BOX_BL}$(printf "%${width}s" | tr ' ' "${BOX_H}")${BOX_BR}${NC}"
}

# Print a status badge
print_badge() {
    local text="$1"
    local color="${2:-${GREEN}}"
    echo -e "${color}${BOLD}[ $text ]${NC}"
}

# --- Decision Pro Admin Mode Detection ---
# Detects production mode from environment variables or .env files
detect_decision_pro_mode() {
  # Check explicit environment variable first
  if [[ -n "${DECISION_PRO_MODE:-}" ]]; then
    echo "${DECISION_PRO_MODE}"
    return 0
  fi
  
  # Check NODE_ENV environment variable
  if [[ "${NODE_ENV:-}" == "production" ]]; then
    echo "production"
    return 0
  fi
  
  # Check .env files in decision-pro-admin directory
  local decision_pro_dir="$ROOT_DIR/decision-pro-admin"
  local env_files=(".env.production" ".env.local")
  
  for env_file in "${env_files[@]}"; do
    local full_path="$decision_pro_dir/$env_file"
    if [[ -f "$full_path" ]]; then
      # Check for NODE_ENV=production in the file
      if grep -q "^NODE_ENV=production" "$full_path" 2>/dev/null || \
         grep -q "^NODE_ENV=\"production\"" "$full_path" 2>/dev/null || \
         grep -q "^NODE_ENV='production'" "$full_path" 2>/dev/null; then
        echo "production"
        return 0
      fi
    fi
  done
  
  # Default to development mode
  echo "dev"
}

# --- Database bootstrap helpers ---
# Supports both Docker and local PostgreSQL

detect_env_file() {
  local candidates=(".env.docker" ".env.development" ".env.production" ".env")
  for f in "${candidates[@]}"; do
    if [[ -f "$ROOT_DIR/$f" ]]; then echo "$ROOT_DIR/$f"; return 0; fi
  done
  echo ""
}

parse_db_env() {
  local env_file="$1"
  # Defaults
  PGHOST="${PGHOST:-localhost}"
  PGPORT="${PGPORT:-5432}"
  PGUSER="${PGUSER:-postgres}"
  PGPASSWORD="${PGPASSWORD:-}"
  PGDATABASE="${PGDATABASE:-ais_credit_scoring}"
  DATABASE_URL="${DATABASE_URL:-}"

  if [[ -n "$env_file" && -f "$env_file" ]]; then
    # Read values without sourcing the file
    while IFS='=' read -r key val; do
      case "$key" in
        PGHOST) PGHOST="${val}" ;;
        PGPORT) PGPORT="${val}" ;;
        PGUSER) PGUSER="${val}" ;;
        PGPASSWORD) PGPASSWORD="${val}" ;;
        PGDATABASE) PGDATABASE="${val}" ;;
        DATABASE_URL) DATABASE_URL="${val}" ;;
      esac
    done < <(grep -E '^(PGHOST|PGPORT|PGUSER|PGPASSWORD|PGDATABASE|DATABASE_URL)=' "$env_file" || true)
  fi

  # If some are missing, try to parse from DATABASE_URL
  if [[ -n "$DATABASE_URL" ]]; then
    local url="$DATABASE_URL"
    local after_scheme="${url#*://}"
    local auth="${after_scheme%@*}"
    local after_at="${after_scheme#*@}"
    local hostport="${after_at%%/*}"
    local dbpath="${after_at#*/}"

    local u="${auth%%:*}"
    local p="${auth#*:}"
    local h="${hostport%%:*}"
    local prt="${hostport#*:}"
    [[ "$prt" == "$hostport" ]] && prt="5432"
    local db="${dbpath%%\?*}"
    db="${db%%/*}"

    [[ -z "$PGUSER" ]] && PGUSER="$u"
    [[ -z "$PGPASSWORD" ]] && PGPASSWORD="$p"
    [[ -z "$PGHOST" ]] && PGHOST="$h"
    [[ -z "$PGPORT" ]] && PGPORT="$prt"
    [[ -z "$PGDATABASE" ]] && PGDATABASE="$db"
  fi
}

have_docker() {
  command -v docker >/dev/null 2>&1
}

have_docker_compose() {
  command -v docker-compose >/dev/null 2>&1
}

db_ready_pg_isready() {
  local host="$1" port="$2" user="$3" db="$4" pwd="$5"
  if command -v pg_isready >/dev/null 2>&1; then
    PGPASSWORD="$pwd" pg_isready -h "$host" -p "$port" -U "$user" -d "$db" -q
    return $?
  fi
  # Fallback: simple TCP check
  if command -v nc >/dev/null 2>&1; then
    nc -z "$host" "$port"
    return $?
  fi
  return 1
}

ensure_database() {
  local env_file; env_file="$(detect_env_file)"
  parse_db_env "$env_file"

  if [[ -z "$PGHOST" ]]; then
    log_warning "No PGHOST found in env. Skipping DB bootstrap."
    return 0
  fi

  log_info "Using DB config from: ${env_file##$ROOT_DIR/}"
  log_info "Target DB: host=$PGHOST port=$PGPORT user=${PGUSER} db=${PGDATABASE}"

  if [[ "$PGHOST" == "postgres-db" ]]; then
    # Docker mode
    if ! have_docker_compose; then
      log_error "docker-compose is required to manage postgres-db. Please install it or use local PostgreSQL."
      return 1
    fi
    log_info "Starting PostgreSQL container..."
    (cd "$ROOT_DIR" && docker-compose up -d postgres-db)
    
    # Wait for readiness
    local max_tries=30; local try=0
    while (( try < max_tries )); do
      if have_docker && docker ps --format '{{.Names}} {{.Status}}' | grep -q '^postgres-db '; then
        if docker exec -e PGPASSWORD="$PGPASSWORD" postgres-db pg_isready -U "$PGUSER" -d "$PGDATABASE" -q; then
          log_success "PostgreSQL container is ready."
          return 0
        fi
      fi
      sleep 1; ((try++))
    done
    log_error "Timed out waiting for PostgreSQL container."
    return 1
  else
    # Local PostgreSQL mode
    log_info "Checking local PostgreSQL..."
    local max_tries=5; local try=0
    while (( try < max_tries )); do
      if db_ready_pg_isready "$PGHOST" "$PGPORT" "$PGUSER" "$PGDATABASE" "$PGPASSWORD"; then
        log_success "PostgreSQL is reachable at $PGHOST:$PGPORT."
        return 0
      fi
      sleep 1; ((try++))
    done
    log_warning "Could not confirm database readiness at $PGHOST:$PGPORT."
    log_warning "Services may fail if database is not available."
    return 0  # Don't fail, just warn
  fi
}

# --- Service management functions ---

pid_file() {
  echo "$PIDS_DIR/$1.pid"
}

log_file() {
  echo "$LOGS_DIR/$1.log"
}

have_cmd() {
  command -v "$1" >/dev/null 2>&1
}

get_pid_for_port() {
  local port="$1"
  # Try ss first (more reliable) - handle both IPv4 and IPv6 formats
  local pid=$(ss -lntp 2>/dev/null | grep -E ":$port " | sed -n 's/.*pid=\([0-9]*\).*/\1/p' | head -n1)
  if [[ -n "$pid" && "$pid" =~ ^[0-9]+$ ]]; then
    echo "$pid"
    return 0
  fi
  # Fallback: try lsof if available
  if command -v lsof >/dev/null 2>&1; then
    local lsof_pid=$(lsof -ti ":$port" 2>/dev/null | head -n1)
    if [[ -n "$lsof_pid" && "$lsof_pid" =~ ^[0-9]+$ ]]; then
      echo "$lsof_pid"
      return 0
    fi
  fi
  # Return empty if nothing found
  echo ""
}

process_alive() {
  local pid="$1"
  [[ -n "$pid" ]] && ps -p "$pid" >/dev/null 2>&1
}

port_busy() {
  local port="$1"
  ss -lntp 2>/dev/null | grep -q ":$port " || lsof -i ":$port" >/dev/null 2>&1
}

is_running() {
  local svc="$1"
  local pf; pf="$(pid_file "$svc")"
  local pid=""
  if [[ -f "$pf" ]]; then
    pid="$(cat "$pf" || true)"
    if process_alive "$pid"; then
      return 0
    fi
  fi
  local port="${SERVICE_PORT[$svc]}"
  if port_busy "$port"; then
    return 0
  fi
  return 1
}

start_service() {
  local svc="$1"
  local port="${SERVICE_PORT[$svc]}"
  local pf; pf="$(pid_file "$svc")"
  local lf; lf="$(log_file "$svc")"
  local cmd=""

  if is_running "$svc"; then
    log_info "$svc is already running (port $port)."
    return 0
  fi

  # Set PYTHONPATH to include project root for all Python services
  export PYTHONPATH="$ROOT_DIR:${PYTHONPATH:-}"

  local bin="${SERVICE_TYPE[$svc]}"
  
  # Special handling for Next.js - check for node/npm and detect mode
  if [[ "$bin" == "nextjs" ]]; then
    if ! have_cmd "node"; then
      log_error "Required command 'node' is not installed or not in PATH."
      return 1
    fi
    if ! have_cmd "npm"; then
      log_error "Required command 'npm' is not installed or not in PATH."
      return 1
    fi
    
    # For Decision Pro Admin, detect mode and set command dynamically
    if [[ "$svc" == "decision_pro_admin" ]]; then
      local mode; mode="$(detect_decision_pro_mode)"
      local decision_pro_dir="$ROOT_DIR/decision-pro-admin"
      
      if [[ "$mode" == "production" ]]; then
        log_info "Starting Decision Pro Admin in PRODUCTION mode"
        
        # Check if build exists, if not build it
        if [[ ! -d "$decision_pro_dir/.next" ]]; then
          log_warning "Production build not found. Building now..."
          cd "$decision_pro_dir"
          if ! npm run build; then
            log_error "Build failed. Cannot start in production mode."
            return 1
          fi
          cd "$ROOT_DIR"
          log_success "Build completed successfully"
        fi
        
        # Use production start command with standalone mode
        # Check if standalone build exists
        if [[ -f "$decision_pro_dir/.next/standalone/server.js" ]]; then
          log_info "Using standalone server mode"
          
          # Copy public assets to standalone directory if needed
          if [[ ! -d "$decision_pro_dir/.next/standalone/public" ]]; then
            log_info "Copying public assets to standalone directory..."
            mkdir -p "$decision_pro_dir/.next/standalone/public"
            cp -r "$decision_pro_dir/public"/* "$decision_pro_dir/.next/standalone/public/" 2>/dev/null || true
            cp -r "$decision_pro_dir/.next/static" "$decision_pro_dir/.next/standalone/.next/" 2>/dev/null || true
          fi
          
          cmd="cd decision-pro-admin/.next/standalone && NODE_ENV=production PORT=$port HOSTNAME=0.0.0.0 node server.js"
        else
          log_warning "Standalone build not found, using npm start (may not work with standalone config)"
          cmd="cd decision-pro-admin && NODE_ENV=production npm start"
        fi
      else
        log_info "Starting Decision Pro Admin in DEVELOPMENT mode"
        cmd="cd decision-pro-admin && npm run dev"
      fi
    else
      # For other Next.js services (if any), use default command
      cmd="${SERVICE_CMD[$svc]}"
    fi
  else
    # For non-Next.js services, use the configured command
    cmd="${SERVICE_CMD[$svc]}"
    if ! have_cmd "$bin"; then
      log_error "Required command '$bin' is not installed or not in PATH."
      return 1
    fi
  fi

  if [[ -z "$cmd" ]]; then
    log_error "Unknown service: $svc or command not configured"
    return 1
  fi

  log_info "Starting $svc on port $port..."
  cd "$ROOT_DIR"
  # For Next.js, ensure we're in the right directory
  if [[ "${SERVICE_TYPE[$svc]}" == "nextjs" ]]; then
    nohup bash -c "cd '$ROOT_DIR' && $cmd" >"$lf" 2>&1 & echo $! >"$pf"
  else
    nohup bash -lc "$cmd" >"$lf" 2>&1 & echo $! >"$pf"
  fi
  sleep 3
  
  if is_running "$svc"; then
    log_success "$svc started successfully"
    echo -e "     ${CYAN}Port:${NC}   $port"
    echo -e "     ${CYAN}Logs:${NC}   $lf"
    echo -e "     ${CYAN}Health:${NC} ${SERVICE_HEALTH[$svc]}"
    [[ -n "${SERVICE_DOCS[$svc]}" ]] && echo -e "     ${CYAN}Docs:${NC}   ${SERVICE_DOCS[$svc]}"
  else
    log_error "Failed to start $svc. Check logs: $lf"
    return 1
  fi
}

stop_service() {
  local svc="$1"
  local pf; pf="$(pid_file "$svc")"
  local port="${SERVICE_PORT[$svc]}"
  local pid=""

  if [[ -f "$pf" ]]; then
    pid="$(cat "$pf" || true)"
  fi

  if [[ -n "$pid" ]] && process_alive "$pid"; then
    log_info "Stopping $svc (pid $pid)..."
    kill -TERM "$pid" || true
    sleep 1
    if process_alive "$pid"; then
      log_warning "Process still running, sending SIGKILL..."
      kill -KILL "$pid" || true
      sleep 1
    fi
    rm -f "$pf"
    log_success "$svc stopped."
    return 0
  fi

  # Fallback: try by port
  local ppid="$(get_pid_for_port "$port")"
  if [[ -n "$ppid" ]]; then
    log_info "Stopping $svc by port $port (pid $ppid)..."
    kill -TERM "$ppid" || true
    sleep 1
    if process_alive "$ppid"; then
      kill -KILL "$ppid" || true
      sleep 1
    fi
    rm -f "$pf"
    log_success "$svc stopped."
    return 0
  fi

  log_info "$svc is not running."
}

restart_service() {
  local svc="$1"
  stop_service "$svc" || true
  sleep 1
  start_service "$svc"
}

# Helper function to format uptime
format_uptime() {
  local seconds=$1
  if [[ -z "$seconds" || "$seconds" == "0" ]]; then
    echo "N/A"
    return
  fi
  
  local days=$((seconds / 86400))
  local hours=$(((seconds % 86400) / 3600))
  local minutes=$(((seconds % 3600) / 60))
  local secs=$((seconds % 60))
  
  if [[ $days -gt 0 ]]; then
    echo "${days}d ${hours}h ${minutes}m"
  elif [[ $hours -gt 0 ]]; then
    echo "${hours}h ${minutes}m ${secs}s"
  elif [[ $minutes -gt 0 ]]; then
    echo "${minutes}m ${secs}s"
  else
    echo "${secs}s"
  fi
}

# Get process resource usage
get_process_stats() {
  local pid="$1"
  if [[ -z "$pid" ]] || ! process_alive "$pid"; then
    echo ""
    return
  fi
  
  # Try to get CPU and memory usage
  if command -v ps >/dev/null 2>&1; then
    local stats=$(ps -p "$pid" -o %cpu,%mem,rss,etime --no-headers 2>/dev/null || echo "")
    if [[ -n "$stats" ]]; then
      echo "$stats"
    fi
  fi
  echo ""
}

# Get service health details
get_service_health_details() {
  local health_url="$1"
  if [[ -z "$health_url" ]]; then
    echo ""
    return
  fi
  
  # Try to fetch health endpoint (with timeout)
  local health_data=$(curl -s -m 2 "$health_url" 2>/dev/null || echo "")
  if [[ -z "$health_data" ]]; then
    echo ""
    return
  fi
  
  # Try to parse JSON (using python if available, otherwise basic grep)
  if command -v python3 >/dev/null 2>&1; then
    python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    uptime = data.get('uptime_seconds', 0)
    version = data.get('version', 'N/A')
    status = data.get('status', 'unknown')
    response_time = data.get('avg_response_time_ms') or data.get('response_time_ms', 0)
    cpu = data.get('cpu_usage_percent', 0)
    memory = data.get('memory_usage_percent', 0)
    print(f'{uptime}|{version}|{status}|{response_time}|{cpu}|{memory}')
except:
    print('')
" <<< "$health_data" 2>/dev/null || echo ""
  else
    echo ""
  fi
}

status_service() {
  local svc="$1"
  local port="${SERVICE_PORT[$svc]}"
  local pf; pf="$(pid_file "$svc")"
  local pid="" state="stopped" state_color="" icon=""
  local uptime_str="N/A" version_str="N/A" response_time="N/A" cpu_usage="N/A" mem_usage="N/A"
  
  if [[ -f "$pf" ]]; then
    pid="$(cat "$pf" || true)"
  fi
  
  if is_running "$svc"; then
    state="running"
    state_color="${GREEN}"
    icon="${ICON_RUNNING}"
    
    # Get detailed information
    local ppid="$(get_pid_for_port "$port")"
    local actual_pid="${pid:-$ppid}"
    
    # Get process stats
    if [[ -n "$actual_pid" ]]; then
      local proc_stats=$(get_process_stats "$actual_pid")
      if [[ -n "$proc_stats" ]]; then
        cpu_usage=$(echo "$proc_stats" | awk '{print $1}')
        mem_usage=$(echo "$proc_stats" | awk '{print $2}')
        local mem_rss=$(echo "$proc_stats" | awk '{print $3}')
        local elapsed=$(echo "$proc_stats" | awk '{print $4}')
        if [[ -n "$elapsed" && "$elapsed" != "-" ]]; then
          uptime_str="$elapsed"
        fi
      fi
    fi
    
    # Get health endpoint details
    local health_url="${SERVICE_HEALTH[$svc]}"
    if [[ -n "$health_url" ]]; then
      local health_details=$(get_service_health_details "$health_url")
      if [[ -n "$health_details" ]]; then
        IFS='|' read -r health_uptime health_version health_status health_response_time health_cpu health_memory <<< "$health_details"
        if [[ -n "$health_uptime" && "$health_uptime" != "0" ]]; then
          uptime_str=$(format_uptime "${health_uptime%.*}")
        fi
        if [[ -n "$health_version" && "$health_version" != "N/A" ]]; then
          version_str="$health_version"
        fi
        if [[ -n "$health_response_time" && "$health_response_time" != "0" ]]; then
          response_time=$(printf "%.0fms" "$health_response_time" 2>/dev/null || echo "N/A")
        fi
        if [[ -n "$health_cpu" && "$health_cpu" != "0" ]]; then
          cpu_usage=$(printf "%.1f%%" "$health_cpu" 2>/dev/null || echo "$cpu_usage")
        fi
        if [[ -n "$health_memory" && "$health_memory" != "0" ]]; then
          mem_usage=$(printf "%.1f%%" "$health_memory" 2>/dev/null || echo "$mem_usage")
        fi
      fi
    fi
  else
    state="stopped"
    state_color="${RED}"
    icon="${ICON_STOPPED}"
  fi
  
  local ppid="$(get_pid_for_port "$port")"
  
  # Enhanced status display with details
  printf "${ICON_SERVICE} %-24s ${state_color}${icon} %-18s${NC} ${CYAN}port=%-6s${NC} ${DIM}pid(file)=%-6s pid(port)=%-6s${NC}
" \
    "$svc" "$state" "$port" "${pid:--}" "${ppid:--}"
  
  # Show additional details if running
  if [[ "$state" == "running" ]]; then
    printf "   ${DIM}â”œâ”€${NC} ${CYAN}Version:${NC} ${BOLD}%-12s${NC} ${CYAN}Uptime:${NC} ${BOLD}%-12s${NC}\n" \
      "$version_str" "$uptime_str"
    printf "   ${DIM}â”œâ”€${NC} ${CYAN}Response:${NC} ${BOLD}%-10s${NC} ${CYAN}CPU:${NC} ${BOLD}%-8s${NC} ${CYAN}Memory:${NC} ${BOLD}%-8s${NC}\n" \
      "$response_time" "$cpu_usage" "$mem_usage"
    printf "   ${DIM}â””â”€${NC} ${CYAN}PID:${NC} ${DIM}%-6s${NC} ${CYAN}Health:${NC} ${GREEN}${SERVICE_HEALTH[$svc]}${NC}\n" \
      "${pid:-$ppid}"
  fi
}

# Docker service status functions
get_docker_container_status() {
  local container_name="$1"
  if ! have_docker; then
    echo "docker_not_available"
    return 1
  fi
  
  local status=$(docker ps -a --filter "name=^${container_name}$" --format "{{.Status}}" 2>/dev/null || echo "")
  if [[ -z "$status" ]]; then
    echo "not_found"
    return 1
  fi
  
  # Check if container is running
  if docker ps --filter "name=^${container_name}$" --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
    # Check health status if available
    local health=$(docker inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "")
    if [[ -n "$health" && "$health" != "<no value>" ]]; then
      echo "running_${health}"
    else
      echo "running"
    fi
  else
    echo "stopped"
  fi
}

# Get Docker container stats
get_docker_stats() {
  local container_name="$1"
  if ! have_docker; then
    echo ""
    return
  fi
  
  # Get container stats (CPU, memory, uptime)
  local stats=$(docker stats --no-stream --format "{{.CPUPerc}}|{{.MemUsage}}|{{.MemPerc}}" "$container_name" 2>/dev/null || echo "")
  if [[ -n "$stats" ]]; then
    echo "$stats"
  else
    echo ""
  fi
}

# Get Docker container uptime
get_docker_uptime() {
  local container_name="$1"
  if ! have_docker; then
    echo ""
    return
  fi
  
  # Get container start time and calculate uptime
  local started=$(docker inspect --format='{{.State.StartedAt}}' "$container_name" 2>/dev/null || echo "")
  if [[ -n "$started" && "$started" != "<no value>" ]]; then
    # Calculate uptime using date command
    if command -v date >/dev/null 2>&1; then
      local start_epoch=$(date -d "$started" +%s 2>/dev/null || echo "")
      local now_epoch=$(date +%s 2>/dev/null || echo "")
      if [[ -n "$start_epoch" && -n "$now_epoch" ]]; then
        local uptime_seconds=$((now_epoch - start_epoch))
        echo "$uptime_seconds"
      fi
    fi
  fi
  echo ""
}

status_docker_service() {
  local container_name="$1"
  local status=$(get_docker_container_status "$container_name")
  local status_text=""
  local status_color=""
  local icon=""
  local uptime_str="N/A"
  local cpu_usage="N/A"
  local mem_usage="N/A"
  local mem_size="N/A"
  local image_name="N/A"
  
  # Skip if container doesn't exist (not_found) unless explicitly requested
  if [[ "$status" == "not_found" ]]; then
    return 0  # Don't display non-existent containers
  fi
  
  case "$status" in
    running_healthy)
      status_text="running (healthy)"
      status_color="${GREEN}"
      icon="${ICON_HEALTHY}"
      ;;
    running_unhealthy)
      status_text="running (unhealthy)"
      status_color="${YELLOW}"
      icon="${ICON_UNHEALTHY}"
      ;;
    running)
      status_text="running"
      status_color="${GREEN}"
      icon="${ICON_RUNNING}"
      ;;
    stopped)
      status_text="stopped"
      status_color="${RED}"
      icon="${ICON_STOPPED}"
      ;;
    docker_not_available)
      status_text="docker unavailable"
      status_color="${YELLOW}"
      icon="${ICON_WARNING}"
      ;;
    *)
      status_text="unknown"
      status_color="${YELLOW}"
      icon="${ICON_WARNING}"
      ;;
  esac
  
  # Get detailed information if running
  if [[ "$status" == "running"* ]]; then
    # Get uptime
    local uptime_seconds=$(get_docker_uptime "$container_name")
    if [[ -n "$uptime_seconds" ]]; then
      uptime_str=$(format_uptime "$uptime_seconds")
    fi
    
    # Get stats
    local stats=$(get_docker_stats "$container_name")
    if [[ -n "$stats" ]]; then
      IFS='|' read -r cpu mem_usage_full mem_perc <<< "$stats"
      cpu_usage=$(echo "$cpu" | sed 's/%//' | xargs)
      mem_usage="$mem_perc"
      mem_size=$(echo "$mem_usage_full" | awk '{print $1}')
    fi
    
    # Get image name
    image_name=$(docker inspect --format='{{.Config.Image}}' "$container_name" 2>/dev/null | cut -d':' -f1 | xargs || echo "N/A")
  fi
  
  # Main status line
  printf "${ICON_DOCKER} %-24s ${status_color}${icon} %-28s${NC} ${DIM}Docker${NC}\n" "$container_name" "$status_text"
  
  # Show additional details if running
  if [[ "$status" == "running"* ]]; then
    printf "   ${DIM}â”œâ”€${NC} ${CYAN}Image:${NC} ${BOLD}%-20s${NC} ${CYAN}Uptime:${NC} ${BOLD}%-12s${NC}\n" \
      "$image_name" "$uptime_str"
    local cpu_display="${cpu_usage}%"
    local mem_display="${mem_usage}%"
    if [[ "$mem_usage" == *"%"* ]]; then
      mem_display="$mem_usage"
    fi
    printf "   ${DIM}â””â”€${NC} ${CYAN}CPU:${NC} ${BOLD}%-8s${NC} ${CYAN}Memory:${NC} ${BOLD}%-10s${NC} ${CYAN}(${mem_size})${NC}\n" \
      "$cpu_display" "$mem_display"
  fi
}

get_docker_services_list() {
  local docker_services=()
  
  # Get all actual Docker containers (running or stopped)
  if have_docker; then
    while IFS= read -r container; do
      if [[ -n "$container" ]]; then
        docker_services+=("$container")
      fi
    done < <(docker ps -a --format "{{.Names}}" 2>/dev/null || true)
  fi
  
  # If no containers found, return empty
  if [[ ${#docker_services[@]} -eq 0 ]]; then
    return 0
  fi
  
  # Return the list
  printf '%s\n' "${docker_services[@]}"
}

show_all_docker_status() {
  local docker_services
  mapfile -t docker_services < <(get_docker_services_list)
  
  # Filter to only show services that actually exist
  local existing_services=()
  for service in "${docker_services[@]}"; do
    local status=$(get_docker_container_status "$service")
    if [[ "$status" != "not_found" ]]; then
      existing_services+=("$service")
    fi
  done
  
  # Display Docker services
  if [[ ${#existing_services[@]} -gt 0 ]]; then
    echo ""
    log_section "Docker Services ${ICON_DOCKER}"
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    for service in "${existing_services[@]}"; do
      status_docker_service "$service"
      echo ""  # Add spacing between services
    done
  elif have_docker; then
    echo ""
    log_section "Docker Services ${ICON_DOCKER}"
    echo -e "${YELLOW}${ICON_WARNING}${NC} No Docker containers found"
  fi
}

start_docker_service() {
  local container_name="$1"
  
  if ! have_docker; then
    log_error "Docker is not installed or not available"
    return 1
  fi
  
  # Check if it's a docker-compose service
  if have_docker_compose && [[ -f "$ROOT_DIR/docker-compose.yml" ]]; then
    local compose_services=$(cd "$ROOT_DIR" && docker-compose config --services 2>/dev/null || echo "")
    if echo "$compose_services" | grep -q "^${container_name}$"; then
      log_info "Starting Docker service $container_name via docker-compose..."
      (cd "$ROOT_DIR" && docker-compose up -d "$container_name")
      return $?
    fi
  fi
  
  # Try to start as a regular container
  if docker ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
    log_info "Starting Docker container $container_name..."
    docker start "$container_name"
    return $?
  else
    log_error "Docker container or service '$container_name' not found"
    return 1
  fi
}

stop_docker_service() {
  local container_name="$1"
  
  if ! have_docker; then
    log_error "Docker is not installed or not available"
    return 1
  fi
  
  # Check if it's a docker-compose service
  if have_docker_compose && [[ -f "$ROOT_DIR/docker-compose.yml" ]]; then
    local compose_services=$(cd "$ROOT_DIR" && docker-compose config --services 2>/dev/null || echo "")
    if echo "$compose_services" | grep -q "^${container_name}$"; then
      log_info "Stopping Docker service $container_name via docker-compose..."
      (cd "$ROOT_DIR" && docker-compose stop "$container_name")
      return $?
    fi
  fi
  
  # Try to stop as a regular container
  if docker ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
    log_info "Stopping Docker container $container_name..."
    docker stop "$container_name"
    return $?
  else
    log_error "Docker container or service '$container_name' not found"
    return 1
  fi
}

restart_docker_service() {
  local container_name="$1"
  stop_docker_service "$container_name" || true
  sleep 1
  start_docker_service "$container_name"
}

logs_service() {
  local svc="$1"; shift || true
  local follow=0 lines=200
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --follow|-f) follow=1 ;;
      --lines|-n) lines="$2"; shift ;;
    esac
    shift || true
  done
  local lf; lf="$(log_file "$svc")"
  if [[ ! -f "$lf" ]]; then
    log_info "No logs yet for $svc at $lf"
    return 0
  fi
  if [[ "$follow" -eq 1 ]]; then
    tail -n "$lines" -f "$lf"
  else
    tail -n "$lines" "$lf"
  fi
}

health_service() {
  local svc="$1"
  local url="${SERVICE_HEALTH[$svc]}"
  if [[ -z "$url" ]]; then
    log_info "No health URL for $svc"
    return 0
  fi
  log_info "Checking health: $url"
  if curl -s -f "$url" > /dev/null 2>&1; then
    log_success "$svc is healthy"
    curl -s "$url" | head -20
  else
    log_error "$svc health check failed"
  fi
}

urls_service() {
  local svc="$1"
  local port="${SERVICE_PORT[$svc]}"
  echo "$svc URLs:"
  [[ -n "${SERVICE_HEALTH[$svc]}" ]] && echo "  Health: ${SERVICE_HEALTH[$svc]}"
  [[ -n "${SERVICE_DOCS[$svc]}" ]] && echo "  Docs:   ${SERVICE_DOCS[$svc]}"
  echo "  Base:   http://localhost:$port/"
}

# --- 144-Feature System Commands ---

generate_data() {
  log_info "=========================================="
  log_info "Generating 164-Feature Training Data (v3.1)"
  log_info "=========================================="
  
  cd "$ROOT_DIR"
  
  if ! have_cmd python3; then
    log_error "Python 3 is required but not found"
    return 1
  fi
  
  log_info "This will generate synthetic training data with 164 features"
  log_info "Includes 20 Digital Behavioral Intelligence features"
  log_info "Estimated time: ~10 minutes"
  echo ""
  
  # Check if 164-feature generator exists
  if [ -f "scripts/data_generation/generate_164_feature_data.py" ]; then
    python3 scripts/data_generation/generate_164_feature_data.py --records "${1:-10000}"
  elif [ -f "generate_144_data.py" ]; then
    log_warn "Using legacy 144-feature generator (164-feature generator not found)"
    python3 generate_144_data.py
  else
    log_error "No data generator found"
    return 1
  fi
  
  if [ $? -eq 0 ]; then
    log_success "Data generation completed successfully"
    log_info "Data saved to: $ROOT_DIR/data/ethiopian_datasets/"
  else
    log_error "Data generation failed"
    return 1
  fi
}

train_models() {
  log_info "=========================================="
  log_info "Training 6-Model Ensemble"
  log_info "=========================================="
  
  cd "$ROOT_DIR"
  
  if ! have_cmd python3; then
    log_error "Python 3 is required but not found"
    return 1
  fi
  
  log_info "This will train all 6 ensemble models"
  log_info "Models: XGBoost, LightGBM, Neural Network, LSTM, Transformer, Meta-Learner"
  log_info "Estimated time: 2-4 hours (or 30 min with quick mode)"
  echo ""
  
  read -p "Use quick mode for testing? (y/N): " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    export QUICK_MODE=true
    log_info "Quick mode enabled"
  fi
  
  python3 scripts/train_144_ensemble.py
  
  if [ $? -eq 0 ]; then
    log_success "Model training completed successfully"
    log_info "Models saved to: $ROOT_DIR/trained_models/"
  else
    log_error "Model training failed"
    return 1
  fi
}

validate_system() {
  log_info "=========================================="
  log_info "Validating 144-Feature System"
  log_info "=========================================="
  
  cd "$ROOT_DIR"
  python3 scripts/validate_144_system.py
}

test_endpoint() {
  log_info "=========================================="
  log_info "Testing 164-Feature Endpoint (v3.1)"
  log_info "=========================================="
  
  cd "$ROOT_DIR"
  
  # Check for 164-feature tests first
  if [ -f "tests/test_164_endpoint_e2e.sh" ]; then
    log_info "Running 164-feature end-to-end tests..."
    bash tests/test_164_endpoint_e2e.sh
  elif [ -f "tests/test_complete_144_endpoint.py" ]; then
    log_warn "Using legacy 144-feature test"
    python3 tests/test_complete_144_endpoint.py
  else
    log_error "No test file found"
    return 1
  fi
}

test_164_features() {
  log_info "=========================================="
  log_info "Testing 164-Feature System"
  log_info "=========================================="
  
  cd "$ROOT_DIR"
  
  # Run unit tests
  if [ -f "tests/test_164_features.py" ]; then
    log_info "Running unit tests..."
    python3 -m pytest tests/test_164_features.py -v
    echo ""
  fi
  
  # Run E2E tests
  if [ -f "tests/test_164_endpoint_e2e.sh" ]; then
    log_info "Running end-to-end tests..."
    bash tests/test_164_endpoint_e2e.sh
  else
    log_error "E2E test script not found"
    return 1
  fi
}

test_products() {
  log_info "=========================================="
  log_info "Testing Product-Specific Endpoints"
  log_info "=========================================="
  
  cd "$ROOT_DIR"
  
  local base_url="http://localhost:${SERVICE_PORT[credit_scoring_service]}"
  local test_data="$ROOT_DIR/data/backup/sample_complete_request.json"
  
  if [ ! -f "$test_data" ]; then
    log_error "Test data not found: $test_data"
    return 1
  fi
  
  echo ""
  log_info "Testing 7 product endpoints..."
  echo ""
  
  # Test Personal Loan
  echo "1ï¸âƒ£  Personal Loan Scorer..."
  curl -s "$base_url/api/v1/products/score/personal-loan" -X POST -H "Content-Type: application/json" -d @"$test_data" | python3 -c "import sys, json; d=json.load(sys.stdin); print('   âœ… Score:', d.get('credit_score', 'Error'), '| Risk:', d.get('risk_level', 'N/A'), '| Max:', d.get('product_specific_data', {}).get('max_loan_amount', 'N/A'))" 2>&1 || echo "   âŒ Failed"
  
  echo ""
  echo "2ï¸âƒ£  BNPL Credit Line Scorer..."
  curl -s "$base_url/api/v1/products/score/credit-line" -X POST -H "Content-Type: application/json" -d @"$test_data" | python3 -c "import sys, json; d=json.load(sys.stdin); print('   âœ… Score:', d.get('credit_score', 'Error'), '| Tier:', d.get('product_specific_data', {}).get('credit_tier', 'N/A'), '| Limit:', d.get('product_specific_data', {}).get('credit_limit', 'N/A'))" 2>&1 || echo "   âŒ Failed"
  
  echo ""
  echo "3ï¸âƒ£  PayBoost Salary Advance..."
  curl -s "$base_url/api/v1/products/score/payboost" -X POST -H "Content-Type: application/json" -d @"$test_data" | python3 -c "import sys, json; d=json.load(sys.stdin); print('   âœ… Approved:', d.get('approved', 'Error'), '| Max:', d.get('product_specific_data', {}).get('max_advance_amount_etb', 'N/A'), '| Fee:', d.get('product_specific_data', {}).get('fee_percentage', 'N/A'))" 2>&1 || echo "   âŒ Failed"
  
  echo ""
  echo "4ï¸âƒ£  Smart Product Selection..."
  curl -s "$base_url/api/v1/products/score/smart" -X POST -H "Content-Type: application/json" -d @"$test_data" | python3 -c "import sys, json; d=json.load(sys.stdin); print('   âœ… Selected:', d.get('selected_product', 'Error'), '| Score:', d.get('credit_score', 'N/A'))" 2>&1 || echo "   âŒ Failed"
  
  echo ""
  echo "5ï¸âƒ£  Product Recommendations..."
  curl -s "$base_url/api/v1/products/recommend" -X POST -H "Content-Type: application/json" -d @"$test_data" | python3 -c "import sys, json; d=json.load(sys.stdin); print('   âœ… Eligible:', d.get('eligible_products', 0), 'products | Top:', d.get('top_recommendation', {}).get('product_type', 'N/A') if d.get('top_recommendation') else 'None')" 2>&1 || echo "   âŒ Failed"
  
  echo ""
  echo "6ï¸âƒ£  Interest Rate Calculator..."
  curl -s "$base_url/api/v1/compliance/interest-rate?credit_score=700&loan_amount=75000&loan_term_months=60" | python3 -c "import sys, json; d=json.load(sys.stdin); print('   âœ… Rate:', f\"{d.get('recommended_interest_rate', 0)*100:.2f}%\", '| Tier:', d.get('risk_tier', 'N/A'))" 2>&1 || echo "   âŒ Failed"
  
  echo ""
  echo "7ï¸âƒ£  Model Health Check..."
  curl -s "$base_url/api/v1/diagnostics/model-health" | python3 -c "import sys, json; d=json.load(sys.stdin); print('   âœ… Status:', d.get('overall_status', 'Error'), '| Models:', len(d.get('model_statuses', {})))" 2>&1 || echo "   âŒ Failed"
  
  echo ""
  log_success "Product endpoint testing complete!"
  echo ""
}

quick_start() {
  log_info "=========================================="
  log_info "144-Feature System Quick Start"
  log_info "=========================================="
  
  cd "$ROOT_DIR"
  
  if [ -f "quick_start_144.sh" ]; then
    bash quick_start_144.sh "$@"
  else
    log_error "quick_start_144.sh not found"
    return 1
  fi
}

show_info() {
  echo ""
  print_box "AIS 164-Feature Credit Scoring System (v3.1)" "${BLUE}"
  echo ""
  echo -e "${BOLD}Running Mode:${NC} LOCAL (without Docker)"
  echo -e "${BOLD}Feature Count:${NC} 164 (144 original + 20 Digital Behavioral Intelligence)"
  echo ""
  log_section "Services ${ICON_SERVICE}"
  for s in "${SERVICES[@]}"; do
    printf "  ${ICON_SERVICE} %-26s ${CYAN}port %-6s${NC}\n" "$s" "${SERVICE_PORT[$s]}"
  done
  echo ""
  log_section "Decision PRO Admin Dashboard"
  echo -e "  ${CYAN}URL:${NC}    http://localhost:${SERVICE_PORT[decision_pro_admin]}"
  echo -e "  ${CYAN}Path:${NC}   $ROOT_DIR/decision-pro-admin"
  local mode; mode="$(detect_decision_pro_mode)"
  echo -e "  ${CYAN}Mode:${NC}   $mode (set via DECISION_PRO_MODE, NODE_ENV, or .env.production/.env.local)"
  echo ""
  log_section "164-Feature System"
  echo -e "  ${CYAN}Data:${NC}   $ROOT_DIR/data/training/"
  echo -e "  ${CYAN}Models:${NC} $ROOT_DIR/trained_models/"
  echo -e "  ${CYAN}Logs:${NC}   $ROOT_DIR/logs/"
  echo ""
  log_section "Quick Commands"
  echo -e "  ${GREEN}./ais generate-data [count]${NC}  - Generate 164-feature training data"
  echo -e "  ${GREEN}./ais train-models${NC}           - Train 6-model ensemble"
  echo -e "  ${GREEN}./ais test-164-features${NC}      - Run comprehensive tests"
  echo -e "  ${GREEN}./ais test-endpoint${NC}          - Test prediction API"
  echo -e "  ${GREEN}./ais validate-system${NC}        - Validate system"
  echo ""
}

list_services() {
  for s in "${SERVICES[@]}"; do
    echo "$s"
  done
}

ps_services() {
  log_info "Listening processes (uvicorn/streamlit/next):"
  ss -lntp 2>/dev/null | grep -E 'uvicorn|streamlit|next' || echo "  No processes found"
}

ports_services() {
  log_info "Configured service ports:"
  for s in "${SERVICES[@]}"; do
    printf "  %-26s %s\n" "$s" "${SERVICE_PORT[$s]}"
  done
}

usage() {
  cat <<EOF
AIS Service Manager - Enhanced for 164-Feature System (v3.1)
Supports both local and Docker deployment

Service Management:
  start   [service|all]        Start one or all services locally
  stop    [service|all]        Stop one or all services
  restart [service|all]        Restart one or all services
  status  [service|all]        Show service status (includes Docker services)
  logs    <service> [--follow] [--lines N]  Show service logs
  health  [service|all]        Check service health endpoints
  urls    [service|all]        Print service URLs

164-Feature System (v3.1 - NEW):
  generate-data [count]        Generate 164-feature synthetic data (default: 10000 records)
  train-models                 Train 6-model ensemble on 164 features
  validate-system              Validate system components
  test-endpoint                Test 164-feature prediction endpoint
  test-164-features            Run comprehensive 164-feature tests (unit + E2E)
  test-products                Test product-specific endpoints (Personal Loan, Credit Line, PayBoost)
  quick-start [options]        Run automated setup script

Utility:
  info                         Show system information
  list                         List all services
  ps                           Show listening processes
  ports                        Show configured ports
  help                         Show this help message

Environment Variables:
  CREDIT_PORT                  Credit scoring service port (default: 4001)
  API_GATEWAY_PORT             API gateway port (default: 4000)
  EXPLAIN_PORT                 Explainability service port (default: 4003)
  DEFAULT_PRED_PORT            Default prediction service port (default: 4002)
  STREAMLIT_PORT               Streamlit dashboard port (default: 4005)
  DECISION_PRO_PORT             Decision PRO admin dashboard port (default: 4009)
  DECISION_PRO_MODE             Decision PRO mode: "dev" or "production" (default: "dev")
                                Also checks NODE_ENV and .env.production/.env.local files
  NODE_ENV                      If set to "production", Decision Pro runs in production mode
  QUICK_MODE                   Enable quick training mode (default: false)

Examples:
  ./ais start                  # Start all services locally
  ./ais status                 # Show status of all services (local + Docker)
  ./ais status postgres-db     # Show status of Docker service
  ./ais start postgres-db      # Start Docker service
  ./ais stop kafka             # Stop Docker service
  ./ais restart redis-cache    # Restart Docker service
  ./ais generate-data          # Generate training data
  ./ais train-models           # Train models
  ./ais start credit_scoring_service  # Start specific local service
  ./ais logs credit_scoring_service --follow  # Follow logs
  ./ais quick-start --skip-docker  # Quick start without Docker
  DECISION_PRO_MODE=production ./ais restart decision_pro_admin  # Start in production mode
  NODE_ENV=production ./ais start decision_pro_admin  # Alternative production mode

Documentation:
  See START_HERE.md for complete setup instructions
  See docs/144_FEATURE_SYSTEM_GUIDE.md for detailed documentation
  See docs/API_REFERENCE_144.md for API documentation
EOF
}

is_docker_service() {
  local service_name="$1"
  
  # Check if it's in the known Docker services list
  local docker_services
  mapfile -t docker_services < <(get_docker_services_list)
  
  for docker_svc in "${docker_services[@]}"; do
    if [[ "$docker_svc" == "$service_name" ]]; then
      return 0
    fi
  done
  
  # Check if it exists as a Docker container
  if have_docker && docker ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${service_name}$"; then
    return 0
  fi
  
  # Check if it's a docker-compose service
  if have_docker_compose && [[ -f "$ROOT_DIR/docker-compose.yml" ]]; then
    local compose_services=$(cd "$ROOT_DIR" && docker-compose config --services 2>/dev/null || echo "")
    if echo "$compose_services" | grep -q "^${service_name}$"; then
      return 0
    fi
  fi
  
  return 1
}

run_for_target() {
  local cmd="$1" target="${2:-all}"; shift 2 || true
  local rest=("$@")
  local targets=()
  local docker_targets=()
  
  if [[ "$target" == "all" ]]; then
    targets=("${SERVICES[@]}")
    # For "all", also include Docker services in status
    if [[ "$cmd" == "status" ]]; then
      mapfile -t docker_targets < <(get_docker_services_list)
    fi
  else
    # Check if target is a Docker service
    if is_docker_service "$target"; then
      docker_targets=("$target")
    else
      targets=("$target")
    fi
  fi
  
  # Before starting all services, ensure the database is available
  if [[ "$cmd" == "start" && "$target" == "all" ]]; then
    ensure_database || {
      log_warning "Database check failed. Services may not work properly."
      read -p "Continue anyway? (y/N): " -n 1 -r
      echo
      [[ ! $REPLY =~ ^[Yy]$ ]] && exit 1
    }
  fi
  
  # Special handling for status command with "all" - show headers and Docker services
  if [[ "$cmd" == "status" && "$target" == "all" ]]; then
    echo ""
    print_box "AIS Platform Service Status" "${BLUE}"
    echo ""
    log_section "Local Services ${ICON_SERVICE}"
    printf "${BOLD}%-26s %-22s %-10s %-12s %-12s${NC}
" "SERVICE" "STATUS" "PORT" "PID(FILE)" "PID(PORT)"
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  fi
  
  # Handle local services
  for svc in "${targets[@]}"; do
    case "$cmd" in
      start)   start_service "$svc" ;;
      stop)    stop_service "$svc" ;;
      restart) restart_service "$svc" ;;
      status)  
        status_service "$svc"
        if [[ "$target" == "all" ]]; then
          echo ""  # Add spacing between services
        fi
        ;;
      health)  health_service "$svc" ;;
      urls)    urls_service "$svc" ;;
      logs)    logs_service "$svc" "${rest[@]}" ;;
    esac
  done
  
  # Handle Docker services
  for docker_svc in "${docker_targets[@]}"; do
    case "$cmd" in
      start)   start_docker_service "$docker_svc" ;;
      stop)    stop_docker_service "$docker_svc" ;;
      restart) restart_docker_service "$docker_svc" ;;
      status)  
        if [[ "$target" == "all" ]]; then
          # Will be shown in show_all_docker_status
          :
        else
          status_docker_service "$docker_svc"
        fi
        ;;
      health)  
        log_info "Health check for Docker service $docker_svc"
        local status=$(get_docker_container_status "$docker_svc")
        if [[ "$status" == "running_healthy" ]]; then
          log_success "$docker_svc is healthy"
        elif [[ "$status" == "running_unhealthy" ]]; then
          log_warning "$docker_svc is running but unhealthy"
        elif [[ "$status" == "running" ]]; then
          log_success "$docker_svc is running (no health check configured)"
        else
          log_error "$docker_svc is not running"
        fi
        ;;
      logs)
        if have_docker; then
          docker logs "$docker_svc" "${rest[@]}" 2>/dev/null || log_error "Failed to get logs for $docker_svc"
        fi
        ;;
      *)
        log_warning "Command '$cmd' not supported for Docker service $docker_svc"
        ;;
    esac
  done
  
  # After showing local services, show Docker services if status command with "all"
  if [[ "$cmd" == "status" && "$target" == "all" ]]; then
    show_all_docker_status
    echo ""
  fi
}

main() {
  local cmd="${1:-help}"; shift || true
  case "$cmd" in
    start|stop|restart|status|health|urls)
      run_for_target "$cmd" "${1:-all}" "${@:2}"
      ;;
    logs)
      if [[ -z "${1:-}" ]]; then 
        log_error "logs requires a service name"
        exit 1
      fi
      run_for_target logs "$1" "${@:2}"
      ;;
    generate-data)
      generate_data ;;
    train-models)
      train_models ;;
    validate-system)
      validate_system ;;
    test-endpoint)
      test_endpoint ;;
    test-164-features)
      test_164_features ;;
    test-products)
      test_products ;;
    quick-start)
      quick_start "$@" ;;
    info)
      show_info ;;
    list)
      list_services ;;
    ps)
      ps_services ;;
    ports)
      ports_services ;;
    help|--help|-h)
      usage ;;
    *)
      log_error "Unknown command: $cmd"
      usage
      exit 1
      ;;
  esac
}

main "$@"
